学习muduo

为什么要用半同步半异步而不是将实际任务放到线程池中呢

##### 一些问题
1. 典型io的两个阶段：数据准备和数据读写
2. 什么是阻塞和非阻塞？数据准备阶段：阻塞：调用io的接口进入阻塞状态，非阻塞：直接返回，不会改变线程状态
3. 什么是同步和异步？数据读写阶段：同步和异步区别就是等不等待读写完成
4. unix五种io模型：阻塞IO，非阻塞IO，IO复用，信号驱动，异步IO
5. 非阻塞socket加IO复用，one loop per thread的设计
6. muduo库中如何让低层级的类使用到高层级类中的方法？一种是在低层级类中包含高层级类的指针直接调用，一种是通过让高层级类初始化低层级类时传入回调函数，这个回调函数就是高层级类中的成员函数可以直接调用高层级类中的方法
7. 低层级类如何控制高层级类的生命周期：Channel中的weak_ptr和tie
8. 如何解决文件描述符大于进程限制的情况：\
    1. 如muduo库，在创建Acceptor监听socket时多申请一个fd（idleFd），让其指向/dev/null的无害文件，当文件描述符达到限制时，会立即释放这个fd让其去accept新连接然后立即关闭连接，从而正确的切断与用户的连接，在做完这些事后这个fd会重新指向/dev/null
    2. 在一开始就申请一个很大的fd数量上限，使用ulimit -n，但这种方法还是有上限
    3. 延迟接受，在fd数量靠近最大值（如90%）时将监听socket从epoll中移除，等到fd数量回到低水位以下后（如60%）在将监听socket加入epoll中
    4. 多进程共同监听一个端口，类似nginx，需要master进程的管理，当一个worker进程的fd满了，master进程会将连接导向其他可用的worker进程


##### 继续实现
1. 双缓冲异步日志
2. 定时队列